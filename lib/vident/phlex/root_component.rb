# frozen_string_literal: true

module Vident
  module Phlex
    class RootComponent < ::Phlex::HTML
      include ::Vident::RootComponent

      STANDARD_ELEMENTS = [:a, :abbr, :address, :article, :aside, :b, :bdi, :bdo, :blockquote, :body, :button, :caption, :cite, :code, :colgroup, :data, :datalist, :dd, :del, :details, :dfn, :dialog, :div, :dl, :dt, :em, :fieldset, :figcaption, :figure, :footer, :form, :g, :h1, :h2, :h3, :h4, :h5, :h6, :head, :header, :hgroup, :html, :i, :iframe, :ins, :kbd, :label, :legend, :li, :main, :map, :mark, :menuitem, :meter, :nav, :noscript, :object, :ol, :optgroup, :option, :output, :p, :path, :picture, :pre, :progress, :q, :rp, :rt, :ruby, :s, :samp, :script, :section, :select, :slot, :small, :span, :strong, :style, :sub, :summary, :sup, :svg, :table, :tbody, :td, :template_tag, :textarea, :tfoot, :th, :thead, :time, :title, :tr, :u, :ul, :video, :wbr].freeze
      VOID_ELEMENTS = [:area, :br, :embed, :hr, :img, :input, :link, :meta, :param, :source, :track, :col].freeze

      VALID_TAGS = Set[*(STANDARD_ELEMENTS + VOID_ELEMENTS)].freeze

      # Build a tag with the attributes determined by this components properties and stimulus
      # data attributes.
      def view_template(&block)
        # Generate tag options and render
        tag_type = content_tag_type
        raise ArgumentError, "Unsupported HTML tag name #{tag_type}" unless VALID_TAGS.include?(tag_type)
        options = @html_options&.dup || {}
        block_content = capture(&block) if block # Evaluate before generating the outer tag options to ensure DSL methods are executed
        data_attrs = stimulus_data_attributes
        data_attrs = options[:data].present? ? data_attrs.merge(options[:data]) : data_attrs
        options = options.merge(id: @id) if @id
        options.except!(:data)
        options.merge!(data_attrs.transform_keys { |k| "data-#{k}" })
        generate_root_tag(tag_type, block_content, **options)
      end

      private

      def generate_tag(tag_name, stimulus_data_attributes, options, &block)
        parsed = parse_targets(Array.wrap(targets))
        options[:data] ||= {}
        options[:data].merge!(build_target_data_attributes(parsed))
        generate_tag(tag_name, nil, **options, &block)
      end

      def generate_root_tag(tag_type, content, **options, &block)
        # FIXME: Content was generated by the block, we assume its safe but that might not be true!
        method_name = (tag_type == :template) ? :template_tag : tag_type
        block = proc { raw content.html_safe } if !block && content
        send(method_name, **options, &block)
      end

      def content_tag_type
        @element_tag.presence&.to_sym || :div
      end
    end
  end
end
